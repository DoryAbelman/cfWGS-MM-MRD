# =============================================================================
# Script: load_process_ig_translocations.R
# 
# Description:
#   This script ingests immunoglobulin (Ig) translocation calls generated by
#   the Ig_caller from cfWGS data, cleans and structures them for downstream
#   integration and figure generation. It performs the following steps:
#     1. Reads all “*_filtered.tsv” outputs in cfWGS_res_dir and extracts only
#        the lines containing “Translocation”.
#     2. Parses each line into columns: breakpoint1/2 (chr:pos), strand,
#        gene1/gene2, IGCaller_Score, Mappability_Issue, plus sample IDs.
#     3. (Optional) Builds a MAVIS‐compatible input table of breakpoints.
#     4. Loads cytoband definitions from “Oct 2024 data/cytoBand.txt” and
#        maps each breakpoint coordinate to its cytoband.
#     5. Flags potential myeloma translocations (t(11;14), t(4;14), t(14;16),
#        t(14;20), t(6;14), t(8;14)) and filters for score/mappability thresholds.
#     6. Annotates each call with:
#         • Common_MM_translocation (1/0 for canonical IGH‐X fusions)
#         • Potential_MM_translocation (1/0 for any IGH‐X event)
#         • Recurrent_TRA (“Yes”/“No” if in chr14q32.33 plus recurrent partner)
#     7. Standardizes “gene1/gene2” into IG_gene and Other_gene, then removes
#        ENCODE blacklist overlaps via GenomicRanges.
#     8. Summarizes counts of patients per gene pair and generates barplots
#        and histograms of fusion frequencies.
# 
# Inputs:
#   • cfWGS_res_dir      = "Oct 2024 data/Ig_caller/"      # Ig_caller “*_filtered.tsv” files
#   • source("GENIUSVariantAnalysis_Functions.R")           # shared helper functions
#   • Cytoband table     = "Oct 2024 data/cytoBand.txt"
#   • ENCODE blacklist   = "hg38-blacklist.v2.bed"
#   • Clinical metadata  = combined_clinical_data_updated_Feb5_2025.csv
# 
# Outputs:
#   • RDS: Oct_2024_Ig_caller_MM_translocations_all.rds
#   • RDS: Oct_2024_Ig_caller_MM_translocations_with_cytoband.rds
#   • RDS: Oct 2024 data/Ig_caller_df_cfWGS_filtered_MM_only_filtered_Ig_caller_outputs_updated2.rds
#   • Summary tables & RDS of translocation matrices
#   • Barplots + histograms under “Oct 2024 data/” directory
# 
# Dependencies:
#   library(ChromHeatMap); data("cytobands")
#   library(tidyverse); library(stringr); library(reshape2)
#   library(ComplexHeatmap); library(RColorBrewer); library(circlize)
#   library(pbapply); library(GenomicRanges)
# 
# Usage:
#   source("load_process_ig_translocations.R")
#   # will produce the filtered RDS objects and summary plots in-place
# 
# Author: Dory Abelman
# Date:   2025-05-26
# =============================================================================



#### Load Libraries 
library(ChromHeatMap)
data("cytobands")
library(tidyverse)
library(stringr)
library(reshape2)
library(ComplexHeatmap)
library(RColorBrewer)
library(circlize)
library(GenomicRanges)
library(pbapply)


source("GENIUSVariantAnalysis_Functions.R")


### Add clinical info
# Load in the patient info 
metada_df_mutation_comparison <- read_csv("combined_clinical_data_updated_Feb5_2025.csv")

# Add a Tumor_Sample_Barcode column to metada_df_mutation_comparison
metada_df_mutation_comparison <- metada_df_mutation_comparison %>%
  mutate(Tumor_Sample_Barcode = Bam %>%
           # Remove _PG or _WG
           str_remove_all("_PG|_WG") %>%
           # Remove anything after ".filter", ".ded", or ".recalibrate"
           str_replace_all("\\.filter.*|\\.ded.*|\\.recalibrate.*", ""))

metada_df_mutation_comparison <- metada_df_mutation_comparison %>%
  mutate(Bam_clean_tmp = gsub(".bam$", "", Bam))  # Remove the '.bam' suffix


### Load raw files
cfWGS_res_dir <- "Oct 2024 data/Ig_caller/"

cfWGS_res_filtered_f <- list.files(cfWGS_res_dir,
                                   pattern = "_filtered.tsv",  
                                   recursive = T,
                                   full.names = T)

cfWGS_res_filtered <- data.frame()

for(f in cfWGS_res_filtered_f){
  
  lns <- readLines(f)
  lns <- subset(lns, grepl("Translocation",lns))
  lns <-  gsub("\\[|\\]", "", lns)
  lns <-  gsub(";chr", "\tchr", lns)
  lns <-  gsub(" - ", "\t", lns)
  lns <-  gsub(":\\+", "\t\\+", lns)
  lns <-  gsub(":-", "\t-", lns)
  
  if(length(lns)>0){
    tmp_res <- read.table(text = lns)
    
    tmp_res <- tmp_res[,c(5,6,7,8,9,10,12,15)]
    colnames(tmp_res) <- c("breakpoint1", "breakpoint1_strand", 
                           "breakpoint2", "breakpoint2_strand",
                           "gene1", "gene2","IGCaller_Score","Mappability_Issue")
    
    tmp_res$Bam_File <- gsub("_output_filtered.tsv",".bam",basename(f))
    
    tmp_res$Sample <- gsub(".sorted_indelrealigned.all.unique.dcs.sorted_output_filtered.tsv","",basename(f))
    
    ## output mavis compatible input
    sep_breakpoint1 <- unlist(strsplit(tmp_res$breakpoint1,":"))
    sep_breakpoint2 <- unlist(strsplit(tmp_res$breakpoint2,":"))
    
    mavis_input <- data.frame(break1_chromosome = sep_breakpoint1[seq(1,length(sep_breakpoint1),2)],
                              break1_position_start = sep_breakpoint1[seq(2,length(sep_breakpoint1),2)],
                              break1_position_end = sep_breakpoint1[seq(2,length(sep_breakpoint1),2)],
                              break2_chromosome = sep_breakpoint2[seq(1,length(sep_breakpoint2),2)],
                              break2_position_start  = sep_breakpoint2[seq(2,length(sep_breakpoint2),2)],
                              break2_position_end  = sep_breakpoint2[seq(2,length(sep_breakpoint2),2)])
    
    #  write.table(mavis_input, row.names = F, sep = "\t",quote = F,
    #               file = gsub(".tsv.txt","_mavis_input.txt",f))
    
    if(f == cfWGS_res_filtered_f[1]){
      cfWGS_res_filtered <- tmp_res
    } else {
      cfWGS_res_filtered <- rbind(cfWGS_res_filtered,
                                  tmp_res)
      
    }
  }
}

## Add cytobands

#cb_frame <- cytobands$`Homo sapiens`
cb_frame <- read_tsv("Oct 2024 data/cytoBand.txt")
colnames(cb_frame) <- c("chr", "start", "end", "band", "stain")

sep_breakpoint1 <- unlist(strsplit(cfWGS_res_filtered$breakpoint1,":"))
sep_breakpoint2 <- unlist(strsplit(cfWGS_res_filtered$breakpoint2,":"))

cfWGS_res_filtered$break1_chromosome <- sep_breakpoint1[seq(1,length(sep_breakpoint1),2)]
cfWGS_res_filtered$break1_position_start  <- sep_breakpoint1[seq(2,length(sep_breakpoint1),2)]
cfWGS_res_filtered$break1_position_end <- cfWGS_res_filtered$break1_position_start

cfWGS_res_filtered$break2_chromosome <- sep_breakpoint2[seq(1,length(sep_breakpoint2),2)]
cfWGS_res_filtered$break2_position_start  <- sep_breakpoint2[seq(2,length(sep_breakpoint2),2)]
cfWGS_res_filtered$break2_position_end <- cfWGS_res_filtered$break2_position_start

cfWGS_res_filtered$break1_cytoband <- NA
cfWGS_res_filtered$break2_cytoband <- NA

saveRDS(cfWGS_res_filtered, "Oct_2024_Ig_caller_MM_translocations_all.rds")

## Filter to MM translocations
cfWGS_res_filtered <- cfWGS_res_filtered %>%
  mutate(Potential_MM_translocation = ifelse(
    (break1_chromosome == "chr11" & break2_chromosome == "chr14") |  # t(11;14)
      (break1_chromosome == "chr14" & break2_chromosome == "chr11") |
      (break1_chromosome == "chr4" & break2_chromosome == "chr14") |   # t(4;14)
      (break1_chromosome == "chr14" & break2_chromosome == "chr4") |
      (break1_chromosome == "chr14" & break2_chromosome == "chr16") |  # t(14;16)
      (break1_chromosome == "chr16" & break2_chromosome == "chr14") |
      (break1_chromosome == "chr14" & break2_chromosome == "chr20") |  # t(14;20)
      (break1_chromosome == "chr20" & break2_chromosome == "chr14") |
      (break1_chromosome == "chr6" & break2_chromosome == "chr14") |   # t(6;14)
      (break1_chromosome == "chr14" & break2_chromosome == "chr6") |
      (break1_chromosome == "chr8" & break2_chromosome == "chr14") |   # t(8;14)
      (break1_chromosome == "chr14" & break2_chromosome == "chr8"),
    1, 0))

# Filter rows where Potential_MM_translocation == 1 (only rows with relevant translocations)
cfWGS_res_filtered <- cfWGS_res_filtered %>%
  filter(Potential_MM_translocation == 1)

# and remove rows where IGCaller_Score <= 20 when Mappability_Issue is not "none"
cfWGS_res_filtered <- cfWGS_res_filtered %>%
  filter(!(IGCaller_Score <= 20 & Mappability_Issue != "none"))

library(pbapply)  # For progress bar

# Function to match cytobands for each breakpoint - much faster than original 
match_cytoband_fast <- function(chromosome, position_start, cb_frame) {
  # Vectorized filtering of the cytoband dataframe
  matched_cb <- cb_frame %>%
    filter(chr == chromosome & start <= as.numeric(position_start) & end >= as.numeric(position_start)) %>%
    slice(1)  # Take the first match
  
  # Return cytoband if a match is found, else NA
  if (nrow(matched_cb) > 0) {
    return(paste0(matched_cb$chr, matched_cb$band))
  } else {
    return(NA)
  }
}

# Apply match_cytoband_fast function with progress bar using pbapply
cfWGS_res_filtered <- cfWGS_res_filtered %>%
  mutate(
    break1_cytoband = pbapply::pbsapply(1:nrow(cfWGS_res_filtered), function(i) {
      match_cytoband_fast(cfWGS_res_filtered$break1_chromosome[i], cfWGS_res_filtered$break1_position_start[i], cb_frame)
    }),
    break2_cytoband = pbapply::pbsapply(1:nrow(cfWGS_res_filtered), function(i) {
      match_cytoband_fast(cfWGS_res_filtered$break2_chromosome[i], cfWGS_res_filtered$break2_position_start[i], cb_frame)
    })
  )

saveRDS(cfWGS_res_filtered, "Oct_2024_Ig_caller_MM_translocations_with_cytoband.rds")


cfWGS_res_filtered$Recurrent_TRA <- "No"

cfWGS_res_filtered$Recurrent_TRA[grepl("11q13|4p16|16q23",
                                       cfWGS_res_filtered$break1_cytoband) &
                                   cfWGS_res_filtered$break2_cytoband == "chr14q32.33"] <- "Yes"

cfWGS_res_filtered$Recurrent_TRA[grepl("11q13|4p16|16q23",
                                       cfWGS_res_filtered$break2_cytoband) &
                                   cfWGS_res_filtered$break1_cytoband == "chr14q32.33"] <- "Yes"

cfWGS_res_filtered$Sample <- gsub(".fastq.gz", "", cfWGS_res_filtered$Sample)

cfWGS_res_filtered$trans_ID <- paste(cfWGS_res_filtered$Sample,
                                     cfWGS_res_filtered$break1_cytoband,
                                     cfWGS_res_filtered$break2_cytoband)


Ig_caller_df_cfWGS_filtered <- cfWGS_res_filtered
## Create a column for if a MM translocation found 

# Replace NAs
Ig_caller_df_cfWGS_filtered$break2_cytoband <- ifelse(is.na(Ig_caller_df_cfWGS_filtered$break2_cytoband), Ig_caller_df_cfWGS_filtered$break2_chromosome, Ig_caller_df_cfWGS_filtered$break2_cytoband)
Ig_caller_df_cfWGS_filtered$break1_cytoband <- ifelse(is.na(Ig_caller_df_cfWGS_filtered$break1_cytoband), Ig_caller_df_cfWGS_filtered$break1_chromosome, Ig_caller_df_cfWGS_filtered$break1_cytoband)

# First create translocation column: 
Ig_caller_df_cfWGS_filtered$Translocation <- paste(Ig_caller_df_cfWGS_filtered$break1_cytoband, Ig_caller_df_cfWGS_filtered$break2_cytoband, sep = "_")

# Then sort it 
# Function to sort the elements in the translocation string
sort_translocation <- function(translocation) {
  parts <- strsplit(translocation, "_")[[1]]
  sorted_parts <- sort(parts)
  return(paste(sorted_parts, collapse = "_"))
}


# Apply the function to the 'Translocation' column and create the new 'sorted_translocation' column
Ig_caller_df_cfWGS_filtered$Sorted_translocation <- apply(Ig_caller_df_cfWGS_filtered["Translocation"], 1, function(x) sort_translocation(x))

# Now see if a myeloma translocation was found 

## These are the most common
myeloma_translocations <- c(
  "chr11q13.3_chr14q32.33",  # t(11;14) involving CCND1 and IGH
  "chr14q32.33_chr16q23.2",  # t(14;16) involving MAF and IGH
  "chr14q32.33_chr20q13.33", # t(14;20) involving MAFB and IGH
  "chr11q13.2_chr14q32.33",  # t(11;14) variation
  "chr14q32.33_chr4p16.3",   # t(4;14) involving FGFR3/MMSET and IGH
  "chr14q32.33_chr6q21",     # t(6;14) involving CCND3 and IGH
  "chr14q32.33_chr8q24.21",  # t(8;14) involving MYC and IGH
  "chr14q32.33_chr6p21"      # t(6;14) involving CCND3 and IGH (variant of Cyclin D deregulation)
)

Ig_caller_df_cfWGS_filtered <- Ig_caller_df_cfWGS_filtered %>%
  mutate(
    Common_MM_translocation = if_else(Sorted_translocation %in% myeloma_translocations, 1, 0)
  )

## These are other potential ones 
# Add the potential_MM_translocation column
Ig_caller_df_cfWGS_filtered <- Ig_caller_df_cfWGS_filtered %>%
  mutate(Potential_MM_translocation = ifelse(
    (break1_chromosome == "chr11" & break2_chromosome == "chr14") |  # t(11;14)
      (break1_chromosome == "chr14" & break2_chromosome == "chr11") |
      (break1_chromosome == "chr4" & break2_chromosome == "chr14") |   # t(4;14)
      (break1_chromosome == "chr14" & break2_chromosome == "chr4") |
      (break1_chromosome == "chr14" & break2_chromosome == "chr16") |  # t(14;16)
      (break1_chromosome == "chr16" & break2_chromosome == "chr14") |
      (break1_chromosome == "chr14" & break2_chromosome == "chr20") |  # t(14;20)
      (break1_chromosome == "chr20" & break2_chromosome == "chr14") |
      (break1_chromosome == "chr6" & break2_chromosome == "chr14") |   # t(6;14)
      (break1_chromosome == "chr14" & break2_chromosome == "chr6") |
      (break1_chromosome == "chr8" & break2_chromosome == "chr14") |   # t(8;14)
      (break1_chromosome == "chr14" & break2_chromosome == "chr8"),
    1, 0))


## Add patient 
Ig_caller_df_cfWGS_filtered <- left_join(Ig_caller_df_cfWGS_filtered, metada_df_mutation_comparison, by = c("Bam_File" = "Bam"))

## Export what have so far 
# Save the dataframe as an RDS file
saveRDS(Ig_caller_df_cfWGS_filtered, "Oct 2024 data/Ig_caller_df_cfWGS_filtered_MM_only_filtered_Ig_caller_outputs_updated2.rds")


## Show recurrent mutations in genes 

Ig_caller_df_cfWGS_filtered <- Ig_caller_df_cfWGS_filtered %>%
  mutate(
    IG_gene = ifelse(!startsWith(gene1, "IG"), gene2, gene1),
    Other_gene = ifelse(!startsWith(gene1, "IG"), gene1, gene2)
  )


## get gene descriptions 

# Get list of all non IGH genes invovled with IG translocation and save to list
unique_genes <- Ig_caller_df_cfWGS_filtered %>%
  dplyr::select(gene1, gene2) %>% 
  unique()

# Reorder columns so Ig on first column 
unique_genes_swapped <- unique_genes %>%
  dplyr::mutate(
    gene1_temp = ifelse(!startsWith(gene1, "IG"), gene2, gene1),
    gene2_temp = ifelse(!startsWith(gene1, "IG"), gene1, gene2)
  ) %>%
  dplyr::select(IG_gene = gene1_temp, Other_gene = gene2_temp)

# List of relevant myeloma genes
relevant_myeloma_genes <- c(
  "FGFR3", "NSD2", "WHSC1",  # t(4;14)
  "CCND1", "CDK6", "BCL1",  # t(11;14)
  "MAF", "MAFB", "ITGB7",  # t(14;16), t(14;20)
  "MYC", "PVT1", "TMPO",  # t(8;14), MYC translocations
  "CCND3", "BMP6", "DUSP22",  # t(6;14)
  "IRF4", "CDKN2C",  # t(1;14)
  "BCL2", "BCL9"  # BCL2-related translocations
)

## First filter pass 
Ig_caller_df_cfWGS_filtered <- Ig_caller_df_cfWGS_filtered %>%
  filter(
    # Keep if there is a mappability issue and score is at least 100
    (Mappability_Issue != "none" & IGCaller_Score >= 100) |
      # Or if there is no mappability issue and score is at least 50
      (Mappability_Issue == "none" & IGCaller_Score >= 50) |
      # Or if it is a common MM translocation and the score is over 15
      (Common_MM_translocation == 1 & IGCaller_Score > 15) |
      # Keep all translocations involving relevant myeloma genes, regardless of score
      (Other_gene %in% relevant_myeloma_genes)
  ) %>%
  filter(Potential_MM_translocation == 1 | Other_gene %in% relevant_myeloma_genes)

## Now remove encode blacklist 
bed_file_encode <- read_tsv("hg38-blacklist.v2.bed")
colnames(bed_file_encode) <- c("chrom", "start", "stop", "description")

# Convert the bed file to a GRanges object
Ig_caller_df_cfWGS_filtered$break1_position_start <- as.numeric(Ig_caller_df_cfWGS_filtered$break1_position_start)
Ig_caller_df_cfWGS_filtered$break1_position_end <- as.numeric(Ig_caller_df_cfWGS_filtered$break1_position_end)
Ig_caller_df_cfWGS_filtered$break2_position_start <- as.numeric(Ig_caller_df_cfWGS_filtered$break2_position_start)
Ig_caller_df_cfWGS_filtered$break2_position_end <- as.numeric(Ig_caller_df_cfWGS_filtered$break2_position_end)

# Create GRanges objects for the filtered Ig caller data and the ENCODE bed file
Ig_caller_df_cfWGS_filtered_gr1 <- GRanges(
  Ig_caller_df_cfWGS_filtered$break1_chromosome,
  IRanges(Ig_caller_df_cfWGS_filtered$break1_position_start, Ig_caller_df_cfWGS_filtered$break1_position_end)
)

Ig_caller_df_cfWGS_filtered_gr2 <- GRanges(
  Ig_caller_df_cfWGS_filtered$break2_chromosome,
  IRanges(Ig_caller_df_cfWGS_filtered$break2_position_start, Ig_caller_df_cfWGS_filtered$break2_position_end)
)

bed_file_gr <- GRanges(
  bed_file_encode$chrom,
  IRanges(bed_file_encode$start, bed_file_encode$stop)
)
# Find the overlaps for both breakpoint1 and breakpoint2
overlaps1 <- findOverlaps(Ig_caller_df_cfWGS_filtered_gr1, bed_file_gr)
overlaps2 <- findOverlaps(Ig_caller_df_cfWGS_filtered_gr2, bed_file_gr)

# Get the indices of the overlapping entries for both breakpoints
overlap_indices1 <- queryHits(overlaps1)
overlap_indices2 <- queryHits(overlaps2)

# Combine the indices from both breakpoints, removing duplicates
all_overlap_indices <- unique(c(overlap_indices1, overlap_indices2))

# Use the combined indices to filter the data frame - to remove entries that overlap
Ig_caller_df_cfWGS_filtered_no_encode <- Ig_caller_df_cfWGS_filtered[-all_overlap_indices,]

## Plot some characteristics of genes affected by more than one patient 

# Get number of patients 

# Group the data by IG_gene and Other_gene and count the unique Patient_ID occurrences
Ig_caller_df_cfWGS_filtered_patient <- Ig_caller_df_cfWGS_filtered_no_encode %>% dplyr::select(Patient, IG_gene, Other_gene, IGCaller_Score) %>% unique() %>% 
  group_by(IG_gene, Other_gene) %>%
  summarise(num_patients = n_distinct(Patient),
            avg_score = mean(IGCaller_Score, na.rm = TRUE),
            median_score = median(IGCaller_Score, na.rm = TRUE),
            sd_score = sd(IGCaller_Score, na.rm = TRUE)) %>%
  ungroup()

## Get only for BM cells 
#BM_cell_patients <- length(unique(samples_available_MYL2$Patient[grepl("BM_cells", samples_available_MYL2$Sample_type)]))


# Add columns 
#Ig_caller_df_cfWGS_filtered_patient <- left_join(Ig_caller_df_cfWGS_filtered_patient, Ig_caller_df_cfWGS_filtered %>% dplyr::select(IG_gene, Other_gene, break1_chromosome, break2_chromosome))

# Create some barplots showing the types of genes involved 

# Create a new column that combines IG_gene and Other_gene values
Ig_caller_df_cfWGS_filtered_patient$gene_pair <- paste(Ig_caller_df_cfWGS_filtered_patient$IG_gene, Ig_caller_df_cfWGS_filtered_patient$Other_gene, sep = "-")

# Order the data frame by num_patients in descending order
Ig_caller_df_cfWGS_filtered_patient <- Ig_caller_df_cfWGS_filtered_patient %>%
  arrange(desc(num_patients))





#### Create some plots to see the rearrangements captured 
# All patients
png(file = paste0("Oct 2024 data/Frequency of repeating rearrangements across patients in cfWGS, all filtered calls", Sys.Date(), ".png"), width = 10, height = 5, units = "in", res = 500)
ggplot(Ig_caller_df_cfWGS_filtered_patient %>% filter(num_patients > 3), aes(x = reorder(gene_pair, num_patients), y = num_patients, fill = median_score)) +
  geom_bar(stat = "identity") +
  scale_fill_gradient(low = "blue", high = "red") +
  theme_classic() +
  labs(x = "Rearrangement", y = "Number of Patients", title = "Frequency of reurring rearrangements across patients",
       subtitle = "Ig oncogenic fusions generated using Ig caller on cfWGS") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = unit(c(0.1, 0.1, 0.1, 0.75), "in")) +
  geom_hline(yintercept = 10, linetype = "dashed", alpha = 0.5) +
  geom_text(aes(label = num_patients), vjust = -0.5, size = 3)
dev.off()

## Do a histogram
png(file = paste0("Oct 2024 data/Histogram of fusions across patients in cfWGS", Sys.Date(), ".png"), width = 10, height = 5, units = "in", res = 500)
ggplot(Ig_caller_df_cfWGS_filtered_patient,
       aes(x = num_patients, y = ..count..)) +
  geom_histogram(binwidth = 1, color = "black", fill = "lightblue") +
  theme_classic() +
  labs(x = "Number of patients a fusion occurs in", y = "Number of fusions", 
       title = "Frequency of Ig fusions across patients",
       subtitle = "Ig oncogenic fusions generated using Ig caller on cfWGS") +
  scale_x_continuous(breaks = seq(0, max(Ig_caller_df_cfWGS_filtered_patient$num_patients), 1)) +
  theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "in")) + 
  geom_text(stat = "count", aes(label = ..count..), vjust = -0.5, size = 3)
dev.off()


## Now create a new barplot with only fusions likely to be invovled in MM


## Create more aggressive filter for poor mapping region
# Apply more aggressive filter while allowing relevant myeloma genes to pass regardless of score
Ig_caller_df_cfWGS_filtered_aggressive <- Ig_caller_df_cfWGS_filtered_no_encode %>%
  filter(
    # Keep if there is a mappability issue and score is at least 100
    (Mappability_Issue != "none" & IGCaller_Score >= 100) |
      # Or if there is no mappability issue and score is at least 50
      (Mappability_Issue == "none" & IGCaller_Score >= 50) |
      # Or if it is a common MM translocation and the score is over 15
      (Common_MM_translocation == 1 & IGCaller_Score > 15) |
      # Keep all translocations involving relevant myeloma genes, regardless of score
      (Other_gene %in% relevant_myeloma_genes)
  ) %>%
  filter(Potential_MM_translocation == 1 | Other_gene %in% relevant_myeloma_genes)


#Group the data by IG_gene and Other_gene and count the unique Patient_ID occurrences
Ig_caller_df_cfWGS_filtered_patient_aggressive <- Ig_caller_df_cfWGS_filtered_aggressive %>%
  group_by(IG_gene, Other_gene) %>%
  summarise(num_patients = n_distinct(Patient),
            avg_score = mean(IGCaller_Score, na.rm = TRUE),
            median_score = median(IGCaller_Score, na.rm = TRUE),
            sd_score = sd(IGCaller_Score, na.rm = TRUE)) %>%
  ungroup()

# Create a new column that combines IG_gene and Other_gene values
Ig_caller_df_cfWGS_filtered_patient_aggressive$gene_pair <- paste(Ig_caller_df_cfWGS_filtered_patient_aggressive$IG_gene, Ig_caller_df_cfWGS_filtered_patient_aggressive$Other_gene, sep = "-")

# Order the data frame by num_patients in descending order
Ig_caller_df_cfWGS_filtered_patient_aggressive <- Ig_caller_df_cfWGS_filtered_patient_aggressive %>%
  arrange(desc(num_patients))

## Need to get the Common MM and potential MM columns
Ig_caller_df_cfWGS_filtered_patient <- left_join(Ig_caller_df_cfWGS_filtered_patient, Ig_caller_df_cfWGS_filtered_no_encode %>% dplyr::select(IG_gene, Other_gene, Common_MM_translocation, Potential_MM_translocation, Sorted_translocation))
Ig_caller_df_cfWGS_filtered_patient <- unique(Ig_caller_df_cfWGS_filtered_patient)

Ig_caller_df_cfWGS_filtered_patient_aggressive <- left_join(Ig_caller_df_cfWGS_filtered_patient_aggressive, Ig_caller_df_cfWGS_filtered_no_encode %>% dplyr::select(IG_gene, Other_gene, Common_MM_translocation, Potential_MM_translocation, Sorted_translocation))
Ig_caller_df_cfWGS_filtered_patient_aggressive <- unique(Ig_caller_df_cfWGS_filtered_patient_aggressive)

## Plot again but filter that Potential == 1

# All patients - top 50 variants
png(file = paste0("Oct 2024 data/Frequency of repeating rearrangements across patients, only MM chromosomes in cfWGS - top 50 ", Sys.Date(), ".png"), width = 10, height = 5, units = "in", res = 500)

top_50_variants <- Ig_caller_df_cfWGS_filtered_patient %>%
  filter(num_patients > 2) %>%
  filter(Potential_MM_translocation == 1) %>%
  arrange(desc(num_patients)) %>%
  head(50)

ggplot(top_50_variants, aes(x = reorder(gene_pair, num_patients), y = num_patients, fill = median_score)) +
  geom_bar(stat = "identity") +
  scale_fill_gradient(low = "blue", high = "red") +
  theme_classic() +
  labs(x = "Rearrangement", y = "Number of Patients", title = "Top 50 Frequency of recurring rearrangements across patients, only MM chromosomes",
       subtitle = "Ig oncogenic fusions generated using Ig caller on 30-40X WGS") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = unit(c(0.1, 0.1, 0.1, 0.75), "in")) +
  geom_hline(yintercept = 10, linetype = "dashed", alpha = 0.5) +
  geom_text(aes(label = num_patients), vjust = -0.5, size = 3)

dev.off()


# Common MM cytobands - top 50 variants
png(file = paste0("Oct 2024 data/Frequency of repeating rearrangements across patients, only MM cytobands in cfWGS - top 50 ", Sys.Date(), ".png"), width = 10, height = 5, units = "in", res = 500)

top_50_common_variants <- Ig_caller_df_cfWGS_filtered_patient %>%
  filter(num_patients > 0) %>%
  filter(Common_MM_translocation == 1) %>%
  arrange(desc(num_patients)) %>%
  head(50)

ggplot(top_50_common_variants, aes(x = reorder(gene_pair, num_patients), y = num_patients, fill = median_score)) +
  geom_bar(stat = "identity") +
  scale_fill_gradient(low = "blue", high = "red") +
  theme_classic() +
  labs(x = "Rearrangement", y = "Number of Patients", title = "Top 50 Frequency of recurring rearrangements across patients, only MM cytobands",
       subtitle = "Ig oncogenic fusions generated using Ig caller on 30-40X WGS") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = unit(c(0.1, 0.1, 0.1, 0.75), "in")) +
  geom_text(aes(label = num_patients), vjust = -0.5, size = 3)

dev.off()

## More agressive filtering 

# Filter out rows where Other_gene starts with "LOC" or "LINC" since likely artifact unless very high score
Ig_caller_df_cfWGS_filtered_aggressive <- Ig_caller_df_cfWGS_filtered_aggressive %>%
  filter(!(grepl("^LOC|^LINC", Other_gene) & IGCaller_Score <= 200))

# More aggressive filtering - top 50 variants
png(file = paste0("Oct 2024 data/Frequency of repeating rearrangements across patients, only MM chromosomes in cfWGS, more aggressive filtering - top 50 ", Sys.Date(), ".png"), width = 10, height = 5, units = "in", res = 500)

top_50_aggressive_variants <- Ig_caller_df_cfWGS_filtered_patient_aggressive %>%
  filter(num_patients >= 1) %>%
  filter(Common_MM_translocation == 1) %>%
  arrange(desc(num_patients)) %>%
  head(50)

ggplot(top_50_aggressive_variants, aes(x = reorder(gene_pair, num_patients), y = num_patients, fill = median_score)) +
  geom_bar(stat = "identity") +
  scale_fill_gradient(low = "blue", high = "red") +
  theme_classic() +
  labs(x = "Rearrangement", y = "Number of Patients", title = "Top 50 Frequency of recurring rearrangements across patients, only MM chromosomes, more aggressive filtering",
       subtitle = "Ig oncogenic fusions generated using Ig caller on 30-40X WGS") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), plot.margin = unit(c(0.1, 0.1, 0.1, 0.75), "in")) +
  geom_hline(yintercept = 10, linetype = "dashed", alpha = 0.5) +
  geom_text(aes(label = num_patients), vjust = -0.5, size = 3)

dev.off()

## Keep the aggressive filter because seems to get rid of most of artifacts, 
## remove variants found in more than 5 patients, about 10% 

# List of key myeloma genes to retain
key_myeloma_genes <- c(
  "CCND1",  # t(11;14) - Cyclin D1 activation
  "FGFR3",  # t(4;14) - FGFR3 activation
  "NSD2",   # t(4;14) - Also called MMSET/WHSC1, chromatin modifier
  "MAF",    # t(14;16) - MAF oncogene activation
  "MAFB",   # t(14;20) - MAFB oncogene activation
  "MYC",    # t(8;14) - MYC overexpression (rare but aggressive)
  "CCND3",  # t(6;14) - Cyclin D3 activation
  "IRF4"    # t(1;14) - IRF4 activation, plasma cell differentiation
)

# Group by IG_gene and Other_gene and count the number of distinct patients with each combination
Ig_caller_df_cfWGS_filtered_aggressive <- Ig_caller_df_cfWGS_filtered_aggressive %>%
  group_by(IG_gene, Other_gene) %>%
  mutate(patient_count = n_distinct(Patient)) %>%  # Count distinct patients per gene combination
  ungroup() %>%
  # Filter to keep combinations found in 2 or fewer patients,
  # or keep if Other_gene is a key myeloma gene and it is a common MM translocation
  filter(patient_count <= 2 | 
           (Other_gene %in% key_myeloma_genes & Common_MM_translocation == 1))

saveRDS(Ig_caller_df_cfWGS_filtered_aggressive, "Oct_2024_Ig_caller_df_cfWGS_filtered_aggressive.rds")

# Stricter filtering 
# while retaining other cases for manual review
Ig_caller_df_cfWGS_filtered_aggressive2 <- Ig_caller_df_cfWGS_filtered_aggressive %>%
  filter(
    # Exclude rows where Mappability_Issue is not "none" and IGCaller_Score <= 100
    !(Mappability_Issue != "none" & IGCaller_Score <= 100)
  ) %>%
  filter(
    # Exclude rows where IGCaller_Score is <= 20, even if Other_gene is NSD2 or MAF
    !(IGCaller_Score <= 20 & Other_gene %in% c("NSD2", "MAF"))
  ) %>%
  filter(
    # Keep rows meeting the following criteria:
    (Mappability_Issue == "none" & IGCaller_Score >= 50) |   # Moderate-confidence calls without mappability issues
      (Common_MM_translocation == 1 & IGCaller_Score >= 40) |  # Low-threshold for common MM translocations
      (Other_gene %in% relevant_myeloma_genes)                # Retain relevant MM genes regardless of score
  )


## Redo patient count 
Ig_caller_df_cfWGS_filtered_aggressive2 <- Ig_caller_df_cfWGS_filtered_aggressive2 %>%
  group_by(IG_gene, Other_gene) %>%
  mutate(patient_count = n_distinct(Patient)) %>%  # Count distinct patients per gene combination
  ungroup()

saveRDS(Ig_caller_df_cfWGS_filtered_aggressive, "Jan_2025_Ig_caller_df_cfWGS_filtered_aggressive.rds")
saveRDS(Ig_caller_df_cfWGS_filtered_aggressive2, "Jan_2025_Ig_caller_df_cfWGS_filtered_extra_aggressive.rds")


#### Now plot

# Create a matrix-like structure with unique combinations of Bam_File, Patient, Timepoint
# Filter for max score to have one row per patient
translocation_matrix <- Ig_caller_df_cfWGS_filtered_aggressive2 %>%
  filter(Other_gene %in% key_myeloma_genes) %>%  # Filter only rows with key translocations
  filter(Common_MM_translocation == 1) %>% 
  group_by(Bam_File) %>%  # Group by Bam_File to identify duplicates
  slice_max(order_by = IGCaller_Score, n = 1, with_ties = FALSE) %>%  # Keep only the row with the highest score
  ungroup() %>%
  dplyr::select(Bam_File, Patient, Timepoint, Sample_type, Sample_ID, timepoint_info, IG_gene, Other_gene) %>%  # Select relevant columns
  distinct() %>%  # Remove duplicates
  # Collapse specific IGH subtypes into general "IGH"
  mutate(IG_gene = ifelse(grepl("^IGH", IG_gene), "IGH", IG_gene)) %>%
  mutate(Translocation = paste(IG_gene, Other_gene, sep = "-")) %>%  # Create a new translocation column
  pivot_wider(
    names_from = Translocation,  # Columns for each translocation
    values_from = Translocation,  # Use the same column to create 1/0
    values_fn = list(Translocation = ~1),  # Set to 1 where translocation exists
    values_fill = 0  # Fill with 0 where translocation doesn't exist
  )


# Correct the summarization of IGH translocations
summarised_translocation_matrix <- translocation_matrix %>%
  # Summarize the IGH translocations by checking if any IGH-related columns have a value of 1
  mutate(IGH_translocation = ifelse(rowSums(across(contains("IGH-"))) > 0, 1, 0)) %>%
  # Drop the individual IGH-* columns
  dplyr::select(-starts_with("IGH-"))  # Remove individual IGH-* columns after collapsing


### Make a seperate one for cytoband 
# Create a matrix-like structure with unique combinations of Bam_File, Patient, Timepoint, etc.
translocation_matrix_cytoband <- Ig_caller_df_cfWGS_filtered_aggressive2 %>%
  filter(Common_MM_translocation == 1) %>%  # Filter rows with common MM translocations
  group_by(Bam_File) %>%  # Group by Bam_File to handle duplicates
  slice_max(order_by = IGCaller_Score, n = 1, with_ties = FALSE) %>%  # Keep only the row with the highest score
  ungroup() %>%
  dplyr::select(Bam_File, Patient, Timepoint, Sample_type, Sample_ID, timepoint_info, Sorted_translocation) %>%  # Select relevant columns
  distinct() %>%  # Remove duplicates
  # Collapse specific IGH subtypes into general "IGH" in the Sorted_translocation column
  mutate(Sorted_translocation = ifelse(grepl("^IGH", Sorted_translocation), sub("_.*", "", Sorted_translocation), Sorted_translocation)) %>%
  pivot_wider(
    names_from = Sorted_translocation,  # Create columns for each translocation type
    values_from = Sorted_translocation,  # Use the same column to create 1/0
    values_fn = list(Sorted_translocation = ~1),  # Set to 1 where translocation exists
    values_fill = 0  # Fill with 0 where translocation doesn't exist
  )


### Now export the screenshotter dataframes for these 
# 1) pivot both breakpoints into one table
screenshotter_df <- Ig_caller_df_cfWGS_filtered_aggressive2 %>%
  filter(Common_MM_translocation == 1) %>% 
  select(
    Bam        = Bam_File,
    Chromosome = break1_chromosome,
    Start      = break1_position_start,
    End        = break1_position_end,
    Name       = Translocation
  ) %>%
  distinct() %>%
  mutate(
    # pull 50 bp upstream, but not below 1:
    Start = pmax(1, Start - 50),
    # push 50 bp downstream:
    End   = End   + 50
  )

# 2) load your “canonical” list of BAMs (no .bam suffix)
current_bams <- read_csv("IG_Mini_Bams.csv")$Name %>%
  str_remove("\\.bam$")

# detect any missing & auto‐map them
screenshot_bams <- str_remove(screenshotter_df$Bam, "\\.bam$")
missing_bams    <- setdiff(screenshot_bams, current_bams)

library(stringdist)

# For each missing BAM, find the closest match in current_bams based on Levenshtein distance
closest_matches <- sapply(missing_bams, function(miss) {
  distances <- stringdist(miss, current_bams, method = "lv")
  current_bams[which.min(distances)]
})

# Combine results into a data frame and print
result <- data.frame(
  Missing_BAM = missing_bams,
  Closest_Match = closest_matches,
  stringsAsFactors = FALSE
)
print(result)

keep <- c( # after manual check to ensure accurate 
  "TFRIM4_0060_Bm_P_WG_FZ-09.filter.deduped.recalibrated",
  "TFRIM4_0178_Bm_P_WG_FZ-07.filter.deduped.recalibrated",
  "TFRIM4_0184_Bm_P_WG_VA-10-01-O-DNA.filter.deduped.recalibrated",
  "TFRIM4_0187_Bm_P_WG_VA-13-01-O-DNA.filter.deduped.recalibrated"
)

# 3. apply any name fixes, then split out groups
screenshotter_df <- screenshotter_df %>%
  mutate(Bam = str_remove(Bam, "\\.bam$")) %>%
  left_join(result, by = c("Bam" = "Missing_BAM")) %>%
  mutate(Bam = coalesce(Closest_Match, Bam)) %>%
  select(-Closest_Match)

# 4. write BEDs
outdir_bed <- "IGV_screenshotter/Bed_files_translocations_cytoband"
if (!dir.exists(outdir_bed)) dir.create(outdir_bed, recursive = TRUE)

write_bed <- function(df, bam_name) {
  bed <- df %>%
    mutate(
      Chromosome = if_else(str_starts(Chromosome,"chr"), Chromosome, paste0("chr",Chromosome)),
      Start      = Start,
      End        = End
    ) %>%
    select(Chromosome, Start, End, Name)
  # write into the outdir:
  write_tsv(bed,
            file.path(outdir_bed, paste0(bam_name, ".bed")),
            col_names = FALSE)
}
  

screenshotter_df %>%
  group_by(Bam) %>%
  group_walk(~ write_bed(.x, .y$Bam))


### Now do for the breakpoint 2
# 1) pivot both breakpoints into one table
screenshotter_df <- Ig_caller_df_cfWGS_filtered_aggressive2 %>%
  filter(Common_MM_translocation == 1) %>% 
  select(
    Bam        = Bam_File,
    Chromosome = break2_chromosome,
    Start      = break2_position_start,
    End        = break2_position_end,
    Name       = Translocation
  ) %>%
  distinct() %>%
  mutate(
    # pull 50 bp upstream, but not below 1:
    Start = pmax(1, Start - 50),
    # push 50 bp downstream:
    End   = End   + 50
  )

# 2) load your “canonical” list of BAMs (no .bam suffix)
current_bams <- read_csv("IG_Mini_Bams.csv")$Name %>%
  str_remove("\\.bam$")

# detect any missing & auto‐map them
screenshot_bams <- str_remove(screenshotter_df$Bam, "\\.bam$")
missing_bams    <- setdiff(screenshot_bams, current_bams)

# For each missing BAM, find the closest match in current_bams based on Levenshtein distance
closest_matches <- sapply(missing_bams, function(miss) {
  distances <- stringdist(miss, current_bams, method = "lv")
  current_bams[which.min(distances)]
})

# Combine results into a data frame and print
result <- data.frame(
  Missing_BAM = missing_bams,
  Closest_Match = closest_matches,
  stringsAsFactors = FALSE
)
print(result)

keep <- c( # after manual check to ensure accurate 
  "TFRIM4_0060_Bm_P_WG_FZ-09.filter.deduped.recalibrated",
  "TFRIM4_0178_Bm_P_WG_FZ-07.filter.deduped.recalibrated",
  "TFRIM4_0184_Bm_P_WG_VA-10-01-O-DNA.filter.deduped.recalibrated",
  "TFRIM4_0187_Bm_P_WG_VA-13-01-O-DNA.filter.deduped.recalibrated"
)

# 3. apply any name fixes, then split out groups
screenshotter_df <- screenshotter_df %>%
  mutate(Bam = str_remove(Bam, "\\.bam$")) %>%
  left_join(result, by = c("Bam" = "Missing_BAM")) %>%
  mutate(Bam = coalesce(Closest_Match, Bam)) %>%
  select(-Closest_Match)

# 4. write BEDs
outdir_bed <- "IGV_screenshotter/Bed_files_translocations_cytoband_breakpoint_2"
if (!dir.exists(outdir_bed)) dir.create(outdir_bed, recursive = TRUE)

write_bed <- function(df, bam_name) {
  bed <- df %>%
    mutate(
      Chromosome = if_else(str_starts(Chromosome,"chr"), Chromosome, paste0("chr",Chromosome)),
      Start      = Start,
      End        = End
    ) %>%
    select(Chromosome, Start, End, Name)
  # write into the outdir:
  write_tsv(bed,
            file.path(outdir_bed, paste0(bam_name, ".bed")),
            col_names = FALSE)
}


screenshotter_df %>%
  group_by(Bam) %>%
  group_walk(~ write_bed(.x, .y$Bam))







# Replace missing values (if any) with 0
translocation_matrix[is.na(translocation_matrix)] <- 0

#  Prepare translocation data
translocation_data <- translocation_matrix %>%
  select(Bam_File, IGH_MAF = `IGH-MAF`, IGH_CCND1 = `IGH-CCND1`, IGH_MYC = `IGH-MYC`, IGH_FGFR3 = `IGH-FGFR3`) %>%
  mutate(Sample = gsub(".bam$", "", Bam_File))  # Remove '.bam' extension if present


translocation_data_cytoband <- translocation_matrix_cytoband %>%
  # first, create IGH_CCND1 by coalescing the two possible 11q13 bands
  mutate(
    IGH_CCND1 = coalesce(
      .data[["chr11q13.2_chr14q32.33"]],
      .data[["chr11q13.3_chr14q32.33"]]
    )
  ) %>%
  # now pick off and rename all four
  transmute(
    Bam_File = Bam_File,
    Sample      = gsub(".bam$", "", Bam_File),        # drop “.bam”
    IGH_CCND1,                                     
    IGH_FGFR3 = `chr14q32.33_chr4p16.3`,
    IGH_MAF   = `chr14q32.33_chr16q23.2`,
    IGH_MYC   = `chr14q32.33_chr8q24.21`
  )

## Export the important tables 
# Define the directory for export
export_dir <- "Jan2025_exported_data"

# Check if the directory exists, if not, create it
if (!dir.exists(export_dir)) {
  dir.create(export_dir)
}

# Exporting dataframes as RDS files
saveRDS(translocation_data, file = file.path(export_dir, "translocation_data.rds"))
saveRDS(translocation_data_cytoband, file = file.path(export_dir, "translocation_data_cytoband.rds"))

# Exporting dataframes as text files
write.table(translocation_data, file = file.path(export_dir, "translocation_data.txt"), sep = "\t", row.names = FALSE, quote = FALSE)
write.table(translocation_data_cytoband, file = file.path(export_dir, "translocation_data_cytoband.txt"), sep = "\t", row.names = FALSE, quote = FALSE)
